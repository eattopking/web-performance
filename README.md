# 学习和性能总结

## 这里是对平时遇到的一些性能问题的总结

1. 强缓存协商缓

2. 本地存储 localstorage, indexdb, sessionstorage, 比如表格替换, 进行缓存数据, 跳转回来不用在了请求, 减少了http请求

3. 使用cdn 缓存图片, 使用webp压缩图片大小

4. 代码方面, react, 将功能拆分, 并且每个功能块, shouldupdate控制更新, 提供的api开关,使用批量更新, 差异更新, 减少和后台交互的字段, 较少数据量, 减少循环的嵌套, 使用高阶组件避免冗余

5. http请求这里使用dns预解析

6. 就是避免重排重绘, 比如获取宽度, js中设置样式

7. 避免内存泄漏

8. 移动端使用ssr优化首屏渲染速度

9. 防止重复请求, 截流防抖

10. 使用transfrom:translate实现移动, 避免使用定位, 因为定位会重复触发浏览器布局和之后的绘制的过程,而transfrom:translate直接跳过了, 布局和绘制, 直接执行了绘制之后的合成过程, 这样减小了浏览器的开销,优化了性能

***
## 对浏览器的一些理解

### 一、浏览器是多进程的, 这样的好处的, 减小影响范围, 一个进程挂了, 不影响其他进程

大概有, 浏览器主进程(控制, 协调的功能, 只有一个), GPU进程(用于3d绘制的, 只有一个), 渲染进程(浏览器每个页签都是一个渲染进程, 可以有多个, 渲染进程里面, 包含js引擎线程, GUI线程(用于渲染html的), js运行线程工作的时候, GUI线程是不工作的, 处于挂起状态, 还有定时器线程, 事件触发线程, 异步http请求线程), network进程(只有一个, 网络请求), audio进程(只有一个, 音频资源的), 插件进程(可以有多个, 每个插件都有一个进程)

### 二、浏览器的渲染过程:

1. 首先解析html文件, 生成dom树
2. 解析css文件生成cssom树
3. 根据cssom树和dom树, 生成一个渲染树, \(render tree\)
4. 进行布局, 对渲染上的每个节点, 进行布局, 确定节点在屏幕上的位置
5. 进行绘制, 在多个层上绘制dom元素
6. 渲染层合并, 按照合理的顺序将多个图层合并, 显示到浏览器上, 后续会出现, 重排, 重绘, 或者直接渲染层合并的情况,transform:translate就是没有重排和重绘, 直接进行了渲染层合并

### 三、 线程和进程的理解

进程是计算机分配资源的最小单位, 进程就是一个应用, (像浏览器的一个页签, 浏览器的一个插件)

线程是程序执行的最小单位, 线程是进程中代码的不同执行路径

### 四 、 html文件, css文件, js文件相互影响关系

1. 谷歌浏览器html 初始化时, 是所有html全部解析完毕后, 在一起渲染, 之后的更新不是全部解析完毕在渲染, 而是解析一定数量之后就就渲染

2. css文件加载, 不影响html元素的解析, 但是阻止html元素的渲染, 这也是浏览器自我优化的一部分, 避免多于的重排和重绘,
css文件加载, 阻止css文件后面的script文件的执行, 等css文件加载完成后, script文件内的代码才继续执行, css加载是并行加载可以多个css同时加载互不影响, css加载不会影响它下面的js文件的下载

3. 正常不加defer 和 async的script标签, 会同步下载和执行js代码, 所以在下载和执行的时候就会阻止html元素的解析,
当添加defer属性时, script标签异步下载js文件, 不会阻塞html元素的解析, 当html元素全部解析完成后, DOMCContentLoaded事件触发之前, 按照加载顺序, 执行js文件, DOMContentLoaded事件就是html全部元素都解析完成后, 就会执行, DOMContentLoaded是document上的事件, 当添加async属性时, 会异步下载和执行js代码, 不会阻塞html元素解析, js代码会异步下载完成后立即异步执行, defer和async都是只在外部引用js文件时生效, 正常不加defer 和 async的script标签会阻塞link元素的解析, 所以会阻塞css的加载

4. load事件 是在window上的事件, 是在整个页面的资源加载完成后执行, 就是页面所有资源都下载并且解析完成之后, 如果没有外部资源, 和DOMContentLoaded一样, 都是在html元素解析完成后执行, 在DOMContentLoaded之后执行, 这里经过实验的结论是对的

5. html元素的解析, 是包括html标签在内的所以元素的解析, 当</html>解析完成后, 才是所有html元素解析完成

### 五 、 浏览器垃圾回收机制

1. 什么是全局变量和局部变量

1.1: 全局变量包括window上的属性, 或者是在全局作用域的变量, 或者是在任意地方的没有变量生命的变量(如b=3, 但是严格模式下, 这样应该是报错的), 但是var 在和const和let一样在大括号中时不会形成块级作用域, 所以var生命的变量可以被括号外面访问到

1.2:  局部变量包括 函数作用域中的函数内的变量和函数的参数

块级作用域中的let 和const生命的变量, 他们只能在块级作用域中被访问到, 其他地方无法访问到

2. 全局变量的生命周期和局部变量的生命周期

2.1:  全局变量的生命周期一直到页面被关闭

2.2: 在函数中的局部变量的生命周期, 正常是函数执行完毕之后, 变量就被销毁, 当在执行函数时在重新声明变量

2.3: 块级作用域中的变量也是感觉应该是全局变量, 页面关闭的时候在销毁, 具体还得看看, 感觉不准

3. 标记清除的时候, 根是什么

全局变量, 局部变量, 内置对象就是根

4. 什么是垃圾

应用程序中的根无法直接或者间接引用到的对象就是垃圾

5. 标记清除和引用计数

标记清除 : 分为标记和清除两个阶段, 这两个阶段都是在一次GC(垃圾回收)中完成的, 就是将应用程序中的根无法直接或者间接引用到的对象的内存回收
引用计数 : 就是一次GC中(垃圾回收), 将引用次数为0的对象的内存回收, 其余的不回收

****
## 对http的一些理解

### 一. 零散知识点理解

1. http的host  就是当前请求的域名
2. location的host就是当前地址栏中的host

### 二. 请求跨域的理解
1. 同源策略是限制谁的？？？？

同源策略是对浏览器的限制, 不是对服务器的限制

2. 同源策略的含义

同源策略的意思是, 当请求时请求的url地址, 与地址栏中的地址的协议, 域名, 端口这三者中有一个不同, 就是跨域了,
跨域时浏览器是可以向服务端发出请求的, 但是服务端返回的数据, 会被浏览器拦截, 认为不安全, 所以不会被浏览器响应
