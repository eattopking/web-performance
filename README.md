# 学习和性能总结

## 这里是对平时遇到的一些性能问题的总结

1. 强缓存协商缓

2. 本地存储 localstorage, indexdb, sessionstorage, 比如表格替换, 进行缓存数据, 跳转回来不用在了请求, 减少了http请求

3. 使用cdn 缓存图片, 使用webp压缩图片大小

4. 代码方面, react, 将功能拆分, 并且每个功能块, shouldupdate控制更新, 提供的api开关,使用批量更新, 差异更新, 减少和后台交互的字段, 较少数据量, 减少循环的嵌套, 使用高阶组件避免冗余

5. http请求这里使用dns预解析

6. 就是避免重排重绘, 比如获取宽度, js中设置样式

7. 避免内存泄漏

8. 移动端使用ssr优化首屏渲染速度

9. 防止重复请求, 截流防抖

10. 使用transfrom:translate实现移动, 避免使用定位, 因为定位会重复触发浏览器布局和之后的绘制的过程,而transfrom:translate直接跳过了, 布局和绘制, 直接执行了绘制之后的合成过程, 这样减小了浏览器的开销,优化了性能
11. service work 就是离线缓存， 在用户没有网的时候也可以用原来的数据进行操作界面

***
## 对浏览器的一些理解

### 一、浏览器是多进程的, 这样的好处的, 减小影响范围, 一个进程挂了, 不影响其他进程

大概有, 浏览器主进程(控制, 协调的功能, 只有一个), GPU进程(用于3d绘制的, 只有一个), 渲染进程(浏览器每个页签都是一个渲染进程, 可以有多个, 渲染进程里面, 包含js引擎线程, GUI线程(用于渲染html的), js运行线程工作的时候, GUI线程是不工作的, 处于挂起状态, 还有定时器线程, 事件触发线程, 异步http请求线程), network进程(只有一个, 网络请求), audio进程(只有一个, 音频资源的), 插件进程(可以有多个, 每个插件都有一个进程)

### 二、浏览器的渲染过程:

1. 首先解析html文件, 生成dom树
2. 解析css文件生成cssom树
3. 根据cssom树和dom树, 生成一个渲染树, \(render tree\)
4. 进行布局, 对渲染上的每个节点, 进行布局, 确定节点在屏幕上的位置
5. 进行绘制, 在多个层上绘制dom元素
6. 渲染层合并, 按照合理的顺序将多个图层合并, 显示到浏览器上, 后续会出现, 重排, 重绘, 或者直接渲染层合并的情况,transform:translate就是没有重排和重绘, 直接进行了渲染层合并

### 三、 线程和进程的理解

进程是计算机分配资源的最小单位, 进程就是一个应用, (像浏览器的一个页签, 浏览器的一个插件)

线程是程序执行的最小单位, 线程是进程中代码的不同执行路径

### 四 、 html文件, css文件, js文件相互影响关系

1. 谷歌浏览器html 初始化时, 是所有html全部解析完毕后, 在一起渲染, 之后的更新不是全部解析完毕在渲染, 而是解析一定数量之后就就渲染

2. css文件加载, 不影响html元素的解析, 但是阻止html元素的渲染, 这也是浏览器自我优化的一部分, 避免多于的重排和重绘,
css文件加载, 阻止css文件后面的script文件的执行, 等css文件加载完成后, script文件内的代码才继续执行, css加载是并行加载可以多个css同时加载互不影响, css加载不会影响它下面的js文件的下载

3. 正常不加defer 和 async的script标签, 会同步下载和执行js代码, 所以在下载和执行的时候就会阻止html元素的解析,
当添加defer属性时, script标签异步下载js文件, 不会阻塞html元素的解析, 当html元素全部解析完成后, DOMCContentLoaded事件触发之前, 按照加载顺序, 执行js文件, DOMContentLoaded事件就是html全部元素都解析完成后, 就会执行, DOMContentLoaded是document上的事件, 当添加async属性时, 会异步下载和执行js代码, 不会阻塞html元素解析, js代码会异步下载完成后立即异步执行, defer和async都是只在外部引用js文件时生效, 正常不加defer 和 async的script标签会阻塞link元素的解析, 所以会阻塞css的加载

4. load事件 是在window上的事件, 是在整个页面的资源加载完成后执行, 就是页面所有资源都下载并且解析完成之后, 如果没有外部资源, 和DOMContentLoaded一样, 都是在html元素解析完成后执行, 在DOMContentLoaded之后执行, 这里经过实验的结论是对的

5. html元素的解析, 是包括html标签在内的所以元素的解析, 当</html>解析完成后, 才是所有html元素解析完成

### 五 、 浏览器垃圾回收机制

1. 什么是全局变量和局部变量

1.1: 全局变量包括window上的属性, 或者是在全局作用域的变量, 或者是在任意地方的没有变量生命的变量(如b=3, 但是严格模式下, 这样应该是报错的), 但是var 在和const和let一样在大括号中时不会形成块级作用域, 所以var生命的变量可以被括号外面访问到

1.2:  局部变量包括 函数作用域中的函数内的变量和函数的参数

块级作用域中的let 和const生命的变量, 他们只能在块级作用域中被访问到, 其他地方无法访问到

2. 全局变量的生命周期和局部变量的生命周期

2.1:  全局变量的生命周期一直到页面被关闭

2.2: 在函数中的局部变量的生命周期, 正常是函数执行完毕之后, 变量就被销毁, 当在执行函数时在重新声明变量

2.3: 块级作用域中的变量也是感觉应该是全局变量, 页面关闭的时候在销毁, 具体还得看看, 感觉不准

3. 标记清除的时候, 根是什么

全局变量, 局部变量, 内置对象就是根

4. 什么是垃圾

应用程序中的根无法直接或者间接引用到的对象就是垃圾

5. 标记清除和引用计数

标记清除 : 分为标记和清除两个阶段, 这两个阶段都是在一次GC(垃圾回收)中完成的, 就是将应用程序中的根无法直接或者间接引用到的对象的内存回收
引用计数 : 就是一次GC中(垃圾回收), 将引用次数为0的对象的内存回收, 其余的不回收

****
## 对http的一些理解

### 一. 零散知识点理解

1. http的host  就是当前请求的域名
2. location的host就是当前地址栏中的host
3. http 报文头， 分为通用报头（请求和响应都能用的）， 请求报头（只有请求能用的），实体报头（用来描述请求实体或者响应实体的）
4. accept 表示客户端希望得到的数据类型， 就是客户端能处理的数据类型， content-type是一个实体头可以描述请求实体也可以描述响应实体，
它表示客户端或者服务端发送的实体的数据类型

5. host 、referer、origin 的区别

域名就是表示ip地址

host是将要请求的 域名 + 端口， 也可以就表示域名

origin 是用来表示请求是从哪个源发送的， 包括协议+域名

referer 表示发送请求的源, 原始的URI, 包括协议 + 域名 + 端口 + 查询字符串（不包括hash部分）



### 二. 请求跨域的理解
1. 同源策略是限制谁的？？？？

同源策略是浏览器对请求和一些东西的限制, 和服务端没有任何关系
(浏览器限制从脚本内发起的跨源HTTP请求)
同源策略限制内容有：

Cookie、LocalStorage、IndexedDB 等存储性内容
DOM 节点
AJAX请求

2. 同源策略的含义

同源策略的意思是, 当请求时请求的url地址, 与地址栏中的地址的协议, 域名, 端口这三者中有一个不同, 那么这次请求就是跨域了,
跨域请求时浏览器是可以向服务端发出请求的, 但是服务端返回的数据, 会被浏览器拦截, 认为不安全, 所以不会被浏览器响应, 所以同源策略就是浏览器自身的一种安全机制

3. 常见的跨域请求解决方案

1. 使用浏览器默认支持跨域的标签, 和后端配合实现跨域, (script标签实现的jsonp就是这个原理), 其他支持跨域的标签还有(img, link);

2. 纯后端处理, 在请求中添加标识字段, 然后后端识别， 在后端进行代理转发， 就是后端当做代理服务器， 然后直接请求真正的数据服务器， 因为后端是没有同源策略限制的，然后代理服务器在把数据返回给浏览器

3. 使用cors(跨域资源共享， 这里浏览器自身提供的一种跨域的机制)实现跨域, 使用cors不仅表示了客户端的权限，也表示了服务端的权限， 服务端允许访问（到这可以实现简单请求）， 并且客户端正式请求的请求头， 服务端都允许， 这样才能发送复杂请求


cors 分为两种： 简单请求、复杂请求

简单请求的标准：
    1. 请求的方法只能是post、get、HEAD
    2. 请求头只能包含在以下这些之中:
        accept(客户端能处理的数据类型)、
        Accept-Language、
        Content-Language、
        Last-Event-ID、
        content-type,
        并且content-type只能是以下几种类型:text/plain、multipart/form-data、application/x-www-form-urlencoded

复杂请求的标准：

    不满足简单请求标准的的就是复杂请求

简单请求和复杂请求的区别：

    1. 两者的标准不同

    2. 发送请求次数不同， 简单请求只发送一次请求， 复杂请求发送两次请求， 浏览器会先自动发送一个options的预请求，
    携带上正式请求的头部去和服务器确认， 如果服务器返回同意这些头部字段， 那浏览器就会发送正式的请求，然后服务器返回数据，浏览器响应解析数据

什么时候会触发cors：

    使用完整的跨域url进行ajax请求， 就是触发cors跨域了

简单请求成功的标准：

    响应头Access-Control-Allow-Origin: 这个字段的值包含当前地址栏中的协议+host（就是包括当前源），这就是表示服务端允许访问了，也表示浏览器看到这个响应头就知道了这个响应是安全的，就会去响应了

复杂请求成功的标准：

    预请求响应头Access-Control-Allow-Origin: 这个字段的值包含当前地址栏中的协议+host（就是包括当前源），表示服务端允许访问了

    预请求的特殊请求头：
        orign: 当前发送跨域请求时， 所在的源（就是地址栏中的协议+host，orign只有在cors跨域的时候才会使用
        Access-Control-Request-Method: POST (正式请求时使用的方法)
        Access-Control-Request-Headers: X-PINGOTHER, Content-Type （正式请求时将携带的请求头， 然后响应返回允许这些请求头， 才可以发送正式请求）

    预请求的特殊响应头：
        Access-Control-allow-origin: http//baidu.com  (表示服务端允许发起跨域请求的源， 如果我们的源包含在这里面才可以发送正式的请求)
        Access-Control-allow-Method: POST(正式请求时允许使用的方法，当正式请求的方法包含在其中时， 才能发起真是的请求)
        Access-Control-allow-Headers: X-PINGOTHER, Content-Type (正式请求时允许允许携带的请求头， 当正式请求的请求头包含这里面时， 才能发送正式请求)

        这三个响应头都满足了，就可以发送正式的请求了，可以发送正式请求就代表可以发送复杂请求了， 可以进行跨域了

### 三. token是什么

    token 称为jwt （json+web+token）

    token就是登录成功之后， 后端在响应体里面返回的，一个字符串， 这个字符串在响应体中对应的key，是前后端商量好的一个字段(不是必须叫token， 也可以叫token1 等等)， token也是起到验证的作用， 登录成功后的接口请求，必须带上token， 否则无法请求。

    token的组成：头部+有效载荷+签名，token是用.分割的字符串

### token和cookie的区别
 1. token是服务端在响应体数据中， 返回给客户端的， 而cookie是服务端在响应头返回给客户端的
 2. token需要前端开发在请求时在请求头上手动添加， 而cookie是在请求时，浏览器自动添加到请求头

 ### token和cookie的相同点

 1. 都是字符串

 ### service worker

    service worker是什么：

     service worker是浏览器支持的一个功能，可以注册一个js脚本， 这个脚本是在一个全新的js线程执行，和页面的js线程不是一个， 并且在window.Navigator.serviceWorker 上提供了一系列的api， 让我们可以实现推送通知，劫持请求， 缓存数据， 后台同步等功能， 结合这些功能实现我们的离线体验


