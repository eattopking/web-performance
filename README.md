# 学习和性能总结

## 这里是对平时遇到的一些性能问题的总结


1. 强缓存协商缓存
2. 本地存储 localstorage, indexdb, sessionstorage, 比如表格替换,进行缓存数据, 跳转回来不用在了请求, 减少了http请求 
3. 使用cdn 缓存图片, 使用webp压缩图片大小
4. 代码方面, react, 将功能拆分, 并且每个功能块,shouldupdate控制更新, 提供的api开关, 
使用批量更新,差异更新,减少和后台交互的字段,较少数据量,减少循环的嵌套, 使用高阶组件避免冗余
5. http请求这里使用dns预解析
6. 就是避免重排重绘, 比如获取宽度, js中设置样式
7. 避免内存泄漏
8. 移动端使用ssr优化首屏渲染速度,
9. 防止重复请求, 截流防抖
10. 使用transfrom:translate实现移动, 避免使用定位, 因为定位会重复触发浏览器布局和之后的绘制的过程, 
而transfrom:translate直接跳过了, 布局和绘制, 直接执行了绘制之后的合成过程, 这样减小了浏览器的开销, 
优化了性能



## 对浏览器的一些理解

一、浏览器是多进程的, 这样的好处的, 减小影响范围, 一个进程挂了,不影响其他进程

大概有,浏览器主进程(控制, 协调的功能, 只有一个), GPU进程(用于3d绘制的,只有一个), 渲染进程(浏览器每个页签都是一个渲染进程,可以有多个,渲染进程里面, 包含js引擎线程, GUI线程(用于渲染html的), js运行线程工作的时候, GUI线程是不工作的, 处于挂起状态, 还有定时器线程, 事件触发线程, 异步http请求线程), network进程(只有一个, 网络请求), audio进程(只有一个,音频资源的), 插件进程(可以有多个, 每个插件都有一个进程)


二、浏览器的渲染过程:

1. 首先解析html文件, 生成dom树
2. 解析css文件生成cssom树
3. 根据cssom树和dom树, 生成一个渲染树, (render tree)
4. 进行布局, 对渲染上的每个节点, 进行布局, 确定节点在屏幕上的位置
5. 进行绘制, 在多个层上绘制dom元素
6. 渲染层合并, 按照合理的顺序将多个图层合并, 显示到浏览器上
6. 后续会出现,重排, 重绘, 或者直接渲染层合并的情况(transform:translate就是没有重排和重绘, 直接进行了渲染层合并)

三、 线程和进程的理解

进程是计算机分配资源的最小单位, 进程就是一个应用,(像浏览器的一个页签, 浏览器的一个插件)

线程是程序执行的最小单位, 线程是进程中代码的不同执行路径





