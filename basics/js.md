# js基础总结

### == 比较的规则
```
1. == 比较会先将两边的数据隐式转换为相同类型， 然后在进行比较
2. null == undefined 是相等的， 而且null 还有 undefined 和其他值比较时不会被隐式转换类型，其他值正常进行隐式转换后也不能转换为null 和 undefined， 和他们类型不同, 所以null 和 undefined和其他值都不相等
3. 在进行原始类型的 == 比较隐式转换过程中， 地位的高低分别为 number（不需要进行隐式转换） > string(和数字进行比较的时候， 要隐式转换为数字后，在和数字进行比较) > boolean （和数字或者字符串进行比较的时候， 要先转换为数字然后在和它们进行比较）
4. 复杂类型 和 原始类型进行 == 比较时， 地位是最低的，首先隐式转换复杂类型为原始类型（就是执行ToPrimitive）， 然后在和原始类型数据进行比较
5. 原始类型进行 == 比较时， 需要两个值类型相同时才开始比较， 除了不能将类型为相同的时候
```

### js 类型转换的步骤， 隐式和显示是相同的步骤， 显式和隐式是从感官上区命名的， 转换原理是相同

```
1. 首先 执行ToPrimitive ， 将值转换为原始值, 执行下面两种转换的前是先执行ToPrimitive
2. 如果要转换为 number就是ToNumber, ToNumber的时候， 首先执行ToPrimitive， 然后将结果转换为number
3. 如果要转换为 string就是ToString, ToString的时候， 首先执行ToPrimitive， 然后将结果转换为string
4. ToPrimitive转换的规则， 就是如果是原始类型， 直接就返回原始类型的值，只有Date实例转化时参数是string， 其他类型转换是参数都是number， 类型是number就是先执行valueOf(), 不行在执行toString(), 而类型是string， 就是先执行toString()，不行在执行valueOf()
```

### js 显式转换

```
!a, +a, Boolean(), String(), Number() 这些都属于js显式转换
```

### js表达式和语句
```
例如这是表达式
3 * 4

每个表达式都有一个结果值，3 * 4这个表达式的结果值，就是3 * 4的结果

表达式和运算符组合在一起就是语句了, 语句有的没有结果值，有的有结果值

let c = a * 4, 这就是语句，这是一个赋值语句

比较特殊的情况
{} ， 既可以表示空对象， 也可以表示一个代码块

{} + [], 这里{}就表示代码块，所有实际代码 就是 +[], 所以结果是0
```

### js运算符优先级

```
() > && > || > ?: > = > ,

let f, t = 12, n  , 这个代码只有t被赋值为12， f和n都是相当于初始化变量， 值都是undefined
```

### js 事件循环的异步操作的理解

js引擎线程就是执行js的， 执行完异步操作的初始化之后， 就会浏览器或者其他js宿主环境就会监听， 异步操作是否完成， 如果完成了， 就会将回调函数放在异步队列里面， 等候在js引擎线程执行

js事件循环的循环的执行顺序是：

1. 同步代码执行
2. 本轮循环执行： 本轮循环包括： node的process.nextTick, 的回调（这是本轮循环中优先级最高的），和微任务队列里边的任务（promise.then的回调就是微任务），微任务的优先级低于process.nextTick的任务， 高于宏任务队列里边的任务，本轮循环执行就是在同步代码执行完之后就立即执行
3. 次轮循环执行： 次轮循环执行就是执行， 宏任务队列里边的任务， 次轮循环执行就是在本轮循环执行完之后执行

宏任务有： setTimeout、setInterval， dom事件

微任务: promise.then 、process.nextTick

不是异步任务的都是同步任务， 同步任务不一定都在层级中，不一定都比异步任务先执行完毕

同步任务的优先级高于异步任务的执行

代码执行就分同步任务和异步任务的执行顺序，不管代码的层级
### async 函数
1. async 函数的调用就是创造promise实例的过程， 所以async 函数的调用就是和new Promise的实例化是一样的， 都是同步的,
所以只要是在async中上面没有await的代码都是同步执行, await后面是同步代码就同步代码正常执行, 异步代码就是异步代码正常执行, 就是await下面的代码不执行, 如果有其他同步代码的话

2. async  await 后面的promise返回状态后， 获取then的值这个回调就被扔到了微任务队列里边， 如果await下面有同步任务就执行同步任务， 执行完同步任务后， 在接着执行可以执行的异步任务, 这个异步任务不一定是在同一个async函数中

3. 如果多个async函数同时执行, 那么多个async函数中的await不是按照async 的执行顺序去返回的, 而是按照异步队列的顺序返回的, 这样就会有一个async中只有await没有返回呢, 就去返回其他async函数中的await了

### js 引擎主线程， 任务队列， 事件队列（也就是异步队列）中任务的执行顺序
1. 首先是主线程上的任务执行完毕， 然后任务队列中有任务，先执行任务队列中任务， 等任务队列中的任务执行完毕了， 才去执行事件队列中的任务
2. 主线程中同时只能执行一个任务
3. 不管事件和任务如何嵌套触发， 事件队列和任务队列一直就只有一个（队列先进先出），js执行的主线程也只有一个， 因为事件和任务都是触发了之后才被放到任务队列或者事件队列中去的， 所以嵌套也是没有关系的， 嵌套的事件和任务在队列中永远在上一个触发的事件和任务之后

### js 已经引擎会先将js代码编译成，执行速度最快的代码， 然后在去执行， 所以我们写的代码和js引擎最后执行的代码可能是不一样的（这也叫js的预编译）， 是js引擎底层提供的优化

### + 隐式转换的规则
```
先从 + 左边的值进行隐式转换， 执行ToPrimitive， 然后在 + 右边的值隐式转换， 执行ToPrimitive， 然后将左右两边的转换结果， 使用 + 组合到一起
```

### 函数默认参数使用
函数后一个参数的默认值可以引用前一个参数的值， 可以是前一个参数的默认值， 或者是调用时传入的值

### try

try 可以和 catch 一起使用， 也可以try .. finally 这样使用

### switch 使用

switch当匹配到的case执行后没有break掉， 会继续执行下面没有匹配到的case的代码， 知道出现break之后才结束

# Promise 总结

1. 所有创建resolve状态Promise的过程， 如果遇到了一个返回，状态返回值就是promise实例的情况， 那就直接展开这个promise实例， 作为需要创建的promise实例的结果

2. 使用.catch去捕获异常， 不要使用.then的第二个参数， 因为.then的第二个参数只能捕获.then对应父级实例创建过程中的异常， 不能在捕获.then第一个参数回调执行过程中的异常了， 但是.catch可以

# ts总结
```
1. 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。
```

# 元素位置和宽高的获取总结

scrollHeight : 元素不包括border，只有padding 和 内容的高度（如果有y轴滚动条， 那内容的高度就是y轴滚动条包含的内容高度）

scrollWidth: 和scrollHeight同理

scrollTop: 没有y轴滚动条时是0，有y轴滚动条时，等于滚动条向上滚动的高度

scrollLeft: 和scrollTop同理

clientHeight: 元素不包括border， 只有padding 和内容的高度， 如果有x轴滚动条，整体高度要减去x轴滚动条的宽度

clientWidth: 和clientHeight同理

clientTop: 元素上边框的宽度， 没有上边框就是0

clientLeft: 元素左边框的宽度， 没有左边框就是0

offsetHeight: 元素包括border在内的高度

offsetWidth: 元素包括border在内的宽度

offsetTop: 元素如果上边有相邻的兄弟元素， 那offsetTop就是元素的上边和上边兄弟元素下边的距离，如果没有，那就是元素上边距离元素父元素上边的距离

offsetLeft: 元素如果左边有相邻的兄弟元素， 那offsetLeft就是元素左边和左边兄弟元素右边的距离，如果没有，那就是元素左边距离元素父元素左边的距离

window.getComputedStyle(元素， null): 获取元素在页面上展示出的真实css属性值， 和css文件设置还是行内样式设置样式无关

element.getBoundingClientRect(): 获取元素相对于视口的位置
```
返回值
{
    top: 元素上边距离视口上边的距离
    bottom: 元素下边距离视口上边的距离
    left: 元素左边距离视口左边的距离
    right: 元素右边距离视口左边的距离
    width: 元素的offsetWidth
    height: 元素的offsetHeight
    x: 元素左边距离视口左边的距离
    y: 元素上边距离视口上边的距离
}
```

# 正则表达式

正则表达式的作用: 匹配完整的字符串， 或者匹配字符串中的一部分， 当时设置了完整的开头和结尾的就是匹配符合规则的完整字符串， 如果只设置了开头或者结尾，那就是匹配对开头和结尾有要求的字符串就可以，如果没有设置开头和结尾，那就是匹配字符串中任意部分

特殊注意点： |（或） 操作符，如果不在分组内（例如:/^1|2$/ ）, 就是作用于整个整个正则表达式的， 意义就是匹配以1开头的或者以2结尾的字符串， 如果 | 在分组中 (例如： /^(1|2)$/), 这是或只作用域正则表达式内部，意思就是匹配只有一个字符的字符串1或者字符串2

（）：分组： 内部可以匹配一个字符，也可以匹配多个字符


# 数组 
  
1. 数字的sort 方法  的回调两个参数分别带代表数组的前后两个值，只有当函数返回值小于0时，两个顺序才发生变化，否则在大于0和等于0时两个值的顺序是不变的


# for 循环 （）中是一个作用域 ，{} 是（）的子作用域， 所以是两个作用域

### 问题

1. 简单介绍一下原型链

说到原型链不得不说的就是函数了，因为原型链的起源就在函数, 首先每个函数都有一个prototype属性, 当我们将这个函数当做构造函数通过new 调用创建一个实例时, 创建的这个实例的__proto__属性就指向构造函数的prototype属性, 而构造函数的prototype属性本身也是一个对象实例，所以它也有__proto__属性，它的__proto__属性指向Object.prototype，Object.prototype也是一个对象实例，所以它也有__proto__属性， 不过它的__proto__属性，指向的是null，这就是原型链的基本链，
还有一些特殊的情况，比如所有的函数都是Function 的实例， 所有Function也是自己的实例， 所以Function.__proto__ === Function.prototype, Object也是Function的实例，原型链不止是__proto__和prototype这样的指向关系，最主要的是对象实例可以通过原型链获取到自己本身没有，但是原型链上有的属性，这才是原型链的本质作用, 我们常说的原型继承就是通过这个原理实现的

2. 说一下对作用域链的理解

说作用域链之前我们得先了解一下我们都有几种作用域， 首先是全局作用域，函数作用域和块级作用域,
此外还有词法作用域就是静态作用域，就是不通过eval等动态执行代码的时候这种作用域，使用eval等执行代码的时候的作用域是动态作用域， 动态和静态作用域都包括全局作用域，函数作用域和块级作用域

作用域的定义我理解就是变量的作用范围， 上下文就是代码执行时候的环境，这个环境就是作用域的作用范围

我们都知道当我们引用一个变量的时候，当前作用域没有， 代码会一直向外层查找变量，一直可以查到全局变量， 如果在全局作用域也没有查找到， 那就是抛错， 这个查找的链路在我理解就是作用域链

查找变量的作用域范围， 静态作用域是在代码解析阶段就确定了， 而动态作用域是在代码执行阶段才确定

3. 介绍一下块级作用域

块级作用域是我们在es6以后提出来的概念，主要是通过let 和const 定义变量所在的块中，就形成一个块级作用域， 比如在一个if {} 中通过let 定义一个变量这个if {}就形成了一个块级作用域， 并且
作用域中的变量不能被块以外的其他区域引用x

4. let const var 的区别

1. let 和const 定义的变量没有变量提升

2. let 和const 创建变量 会形成一个块级作用域

3. 在let 或者const 的变量之前引用这个变量，或者使用typeof或者这个变量的类型， 都会报错，这都是因为引用变量的范围都在暂时性死区中， 所以才会报错
4. 由于let 和const 没有变量提升， 所以在变量定义之前引用变量都是在暂时性死区中

5. let 和const 定义变量之前就是暂时性死区， 所以在let和const定义变量之前引用变量就会报错，
产生暂时性死区就是代码解析阶段发现引用变量是被let和const定义的，那就认为这个变量的的查找只能在当前let和const定义的块级作用域内，如果变量是在声明前引用那就是在暂时性死区， 就会报错,

暂时性死区是作用域链的一种特殊情况， 就是let 定义之前引用这个变量，这个变量在解析阶段，它的查找范围就已经被确定在let 和const定义变量的这个块级作用域中了， 所以暂时性死


5. 介绍一下闭包

我理解的闭包就是 在当前作用域下声明的函数，在当前作用域以外的作用域被调用，就形成了闭包， 比如注册事件的回调，这就形成了一个闭包

闭包的作用就是保存变量， 让函数内的变量可以被函数外部使用和操作

但是很使用闭包的时候也需要注意，可能会出现内存泄露的问题，影响页面的性能

6. 函数引用变量和后续子级引用相同变量的原理
函数执行完之后会将执行那个时刻的变量作用域缓存, 这个时候函数中子级引用变量时, 引用的是缓存的结果,
只有父级函数重新被调用变量作用域才会更新, 缓存值也才会更新


7. 介绍一下页面的垃圾回收机制

垃圾回收机制是浏览器的一种优化策略（垃圾回收机制准确说是V8引擎这个js引擎线程的优化策略）， 当触发垃圾回收机制的时候， 会将不需要在使用的内存（就是分配给V8引擎的内存）释放掉，然后将内存分配给需要的变量，垃圾回收的方式一般 分为三中 引用计数、标记清除、和标记整理，我们现在的浏览器都是标记清除和标记整理两种形式一起使用，因为标记清除相对标记整理进行垃圾回收的速度更快，因为标记清除不需要移动对象， 而标记整理需要移动对象， 所以速度更慢, 但是在标记清除也有自己的问题，就是垃圾回收后的内存不连续，导致虽然垃圾回收后，所剩内存的总和是够的， 但是不能总的内存一次分配给一个对象，所有这种情况下，就需要使用标记管理，标记管理可以使回收后的内存连起来，但是由于垃圾回收也是占用浏览器主线程的，所以执行垃圾回收的时候js代码不会执行， 页面渲染也不会执行，影响页面展示，所以垃圾回收的时间也不适宜太长， 所以主要是使用标记清除的方式

8. 什么时候触发垃圾回收机制呢

执行垃圾回收的时间是周期性的， 隔一段时间机会进行一次垃圾回收，不会是函数完毕就会触发垃圾回收, 但是也不是固定的， 可能在内存消耗过大时， 提前开启垃圾回收

9. 函数只有在每次调用的时候才会创建这个函数执行上下文和作用域，还有为函数中的变量分配内存，但是函数执行完毕后， 执行上下文和作用域都会销毁，给变量分配的内存也会在下一次垃圾回收的时候被收回

还有给变量设置为null之后， 之前分配的内存都会被回收

#### 不会被回收的内存

1. window 本事永远不会被回收，

2. window 上的全局属性永远不会被回收，

3. 全局变量引用的对象永远不会被回收

4. 闭包函数返回的函数所引用的闭包函数中的变量， 不会被回收， 除非接收这个返回函数的变量置为null， 才会被回收

5. 还有就是最正常的情况，当前正在使用这个变量时， 内存不会被回收

9. 什么是浏览器的主进程

浏览器主进程就是将js引擎线程和GUi渲染线程等真实的线程包装成一个虚拟的线程，然后根据情况，采用不同的真实线程处理任务， 所以说浏览器主线程可以说是一个概念，并不是一个真正的线程



### typeof

typeof的原理就是，判断变量机器码的前三位，object前三位是000，因为null的机器码所有位数都是0，所以null使用typeof检查类型的时候返回object


### 如果给apply bind call 传递改变this指向 的值是undefined 或者是null，这个时候不会改变函数执行时候的this指向


### instanceof 检验数据类型的原理

instanceof 检验数据类型的原理， 就是看左边的实例的原型链上有没有， 右边构造函数的原型，有的话，左边实例就属于这个这个类型，没有就不属于这个类型， 还是通过原型继承的原理来判断数据类型的

// 基本实现， right这边没有做判断
const newInstanceof (left, right) {
 if (left == null) {
     return false;
 }
 let new__proto__ = left.__proto__;
 while(new__proto__) {
     if (new__proto__ === right.prototype) {
         return true;
     }

     new__proto__ = new__proto__.__proto__;
 }

 return false;
}

### 0.1 加上0.2 为啥等于0.3

因为js 中的number类型是通过IEEE754标准表示的， 0.1 + 0.2 计算的时候会先转化成二进制然后在计算， 最后转换为10进制， 这个过程中会发生精度丢失, 导致计算出来的结果比0.3大， 导致0.1+0.2不等于0.3

#### promise 创建resolve 状态的promise的过程，如果遇到resolve的返回值是一个promise实例的（不管是resolve状态还是reject状态），本次创建promise的实例就是这个返回值了， 创建reject状态的Promise就没有这个规则， 它就是正常的规则


### 函数柯理化

什么是函数柯理化

函数柯理化就是将多个参数的函数， 转换成一系列单个参数的函数

函数柯理化有啥意义呢

将函数变得更加有适用性


#### 事件相关


什么是事件流

事件流就是触发事件之后，事件的执行过程，事件的执行过程分为三个阶段：

1. 首先是捕获阶段， 就是从document开始， 向触发了这个事件的元素，开始查询， 如果有元素注册相同类型的事件， 并且允许在捕获阶段执行，那就执行这个元素的事件回调

2. 然后是目标阶段， 就是看我们触发事件的这个元素是否注册了这个类型的事件，注册了就执行这个事件的回调函数（不管是注册的允许在冒泡阶段执行的事件，还是注册的允许在捕获阶段执行的事件在目标阶段都会被执行）

3. 最后就是冒泡阶段， 从触发事件的元素向document方向，开始查询， 如果有父元素注册了相同类型的事件，并且允许在冒泡阶段执行， 那就是执行这个事件回调



事件对象中的target， currentTarget， 事件回调中的this，分别表示什么， 它们都是在执行事件回调的时候获取的

target表示我们触发这个事件的这个元素

currentTarget表示执行事件回调时， 注册这个事件回调的元素

this表示执行事件回调时，注册这个事件回调的元素


模块化和进程的关系:

模块化都是只能在同一个进程中共享的引用和修改引用的, 不同进程之间虽然都引用了相同模块, 但是他们的引用都是隔离的, 互不影响


