## 对浏览器的一些理解

### 一、浏览器是多进程的, 这样的好处的, 减小影响范围, 一个进程挂了, 不影响其他进程

1. 浏览器主进程(browser进程)(是所有其他进程的祖先，可以理解为父类，负责页面的显示 各个页面的管理和协调, 还有创建和销毁其他进程，主进程只有一个)
2. renderer进程， 网页渲染进程, 主要负责页面的渲染， renderer进程可以有多个， 但是和打开页面的数量不一定相等
3. NPAPI插件进程，插件进程， 每种插件只能创建一个进程， 多个网页使用相同插件时， 对应的插件进程会为不同网页创建实例, 所以同一个插件进程是被所以网页共享的， NPAPI插件进程服务于NPAPI插件
4. Pepper插件进程： 和NPAPI插件进程进程的作用是一样的， Pepper插件进程服务于Pepper插件
5. GPU进程, 只有当GPU硬件加速打开时， 才会创建GPU进程， GPU进程只有一个，GPU进程主要用于对3D图形的加速调用
6. 渲染进程(浏览器每个页签都是一个渲染进程, 可以有多个, 渲染进程里面, js引擎和GUI渲染是在一个线程上的， , js运行线程工作的时候, GUI渲染是不工作的, 处于挂起状态, 还有定时器线程, 事件触发线程, 异步http请求线程),
7. network进程(只有一个, 网络请求),
8. audio进程(只有一个, 音频资源的)
9. 浏览器多个进程之间是独立的， 不会相互影响

### 二、浏览器的渲染过程:

1. Parse html - 首先解析html文件, 生成dom树
2. 解析css文件生成cssom树
3. 进行布局, 对渲染上的每个节点, 进行布局, 确定节点在屏幕上的位置, dom树根据cssom树的信息, 生成一个渲染树, \(render tree\)
4. Layout(布局)
5. layer tree 生成图层树
6. 在每个图层上绘制展示内容 - paint过程
7. update layer - 更新图层
8. 将多个图层合并, 按照合理的顺序将多个图层合并, 显示到浏览器上 - composite过程
9. 将最终的图层展示到页面上
10. 后续会出现, 重排, 重绘, 图层合并的情况,transform:translate就是只进行了update layer tree (更新图层树) 、paint、update layer和图层合并， 没有进行重排，只进行了重绘, 这也是开启了硬件加速
### 三、 线程和进程的理解

进程是计算机分配资源的最小单位, 进程就是一个应用, (像浏览器的一个页签, 浏览器的一个插件)

线程是程序执行的最小单位, 线程是进程中代码的不同执行路径

### 四 、 html文件, css文件, js文件相互影响关系

1. 谷歌浏览器html 初始化时, 是所有html全部解析完毕后, 在一起渲染, 之后的更新不是全部解析完毕在渲染, 而是解析一定数量之后就就渲染

2. css文件加载, 不影响html元素的解析, 但是阻止html元素的渲染, 这也是浏览器自我优化的一部分, 避免多于的重排和重绘,
css文件加载, 阻止css文件后面的script文件的执行, 等css文件加载完成后, script文件内的代码才继续执行, css加载是并行加载可以多个css同时加载互不影响, css加载不会影响它下面的js文件的下载

3. 正常不加defer 和 async的script标签, 会同步下载和执行js代码, 所以在下载和执行的时候就会阻止html元素的解析,
当添加defer属性时, script标签异步下载js文件, 不会阻塞html元素的解析, 当html元素全部解析完成后, DOMCContentLoaded事件触发之前, 按照加载顺序, 执行js文件, DOMContentLoaded事件就是html全部元素都解析完成后, 就会执行, DOMContentLoaded是document上的事件, 当添加async属性时, 会异步下载和执行js代码, 不会阻塞html元素解析, js代码会异步下载完成后立即异步执行, defer和async都是只在外部引用js文件时生效, 正常不加defer 和 async的script标签会阻塞link元素的解析, 所以会阻塞css的加载

4. load事件 是在window上的事件, 是在整个页面的资源加载完成后执行, 就是页面所有资源都下载并且解析完成之后, 如果没有外部资源, 和DOMContentLoaded一样, 都是在html元素解析完成后执行, 在DOMContentLoaded之后执行, 这里经过实验的结论是对的

5. html元素的解析, 是包括html标签在内的所以元素的解析, 当</html>解析完成后, 才是所有html元素解析完成

### 五 、 浏览器垃圾回收机制

1. 什么是全局变量和局部变量

1.1: 全局变量包括window上的属性, 或者是在全局作用域的变量, 或者是在任意地方的没有变量生命的变量(如b=3, 但是严格模式下, 这样应该是报错的), 但是var 在和const和let一样在大括号中时不会形成块级作用域, 所以var生命的变量可以被括号外面访问到

1.2:  局部变量包括 函数作用域中的函数内的变量和函数的参数

块级作用域中的let 和const生命的变量, 他们只能在块级作用域中被访问到, 其他地方无法访问到

2. 全局变量的生命周期和局部变量的生命周期

2.1:  全局变量的生命周期一直到页面被关闭

2.2: 在函数中的局部变量的生命周期, 正常是函数执行完毕之后, 变量就被销毁, 当在执行函数时在重新声明变量

2.3: 块级作用域中的变量也是感觉应该是全局变量, 页面关闭的时候在销毁, 具体还得看看, 感觉不准

3. 标记清除的时候, 根是什么

全局变量, 局部变量, 内置对象就是根

4. 什么是垃圾

应用程序中的根无法直接或者间接引用到的对象就是垃圾

5. 标记清除和引用计数

标记清除 : 分为标记和清除两个阶段, 这两个阶段都是在一次GC(垃圾回收)中完成的, 就是将应用程序中的根无法直接或者间接引用到的对象的内存回收
引用计数 : 就是一次GC中(垃圾回收), 将引用次数为0的对象的内存回收, 其余的不回收

### 六 、 浏览器垃圾回收机制

service worker是什么：

     service worker是浏览器支持的一个功能，可以注册一个js脚本， 这个脚本是在一个全新的js线程执行，和页面的js线程不是一个， 并且在window.Navigator.serviceWorker 上提供了一系列的api， 让我们可以实现推送通知，劫持请求， 缓存数据， 后台同步等功能， 结合这些功能实现我们的离线体验

### 七 、 浏览器下载问题
     **我们正常请求文件资源， 图片资源，返回的就是文件流

     文件流和Blob二进制对象，还有file二进制对象，是两个东西， 不一样， 文件流可以转换为Blob二进制对象

     浏览器下载， 浏览器可直接浏览的文件类型是不提供下载的, 直接预览， 这是浏览器的默认机制

     现在比较常见的是a标签的download可以是实现所有文件的下载， 但是download有个特性，就是跨域请求的资源， download的下载属性就消失了

     给download设置的值就是下载后的文件名称， 不包括后缀

     正常后端给的就是文件流

     ```
          具体代码如下：

              需要注意的是，代码中对创建的<a> 进行的 appendChild 和 remove 操作主要是为了兼容 FireFox 浏览器，在 FireFox 浏览器下      调用该方法如果不将创建的<a>标签添加到 body 里，点击链接不会有任何反应，无法触发下载，而在 Chrome 浏览器中则不受此影响。

              function download(href, filename = '') {
                  // download属性目前仅适用于同源 URL
                  const a = document.createElement('a');
                  a.download = filename;
                  a.href = href;
                  document.body.appendChild(a);
                  a.click();
                  a.remove();
              }

              function downloadFile(url, filename = '') {
                  fetch(url, {
                      headers: new Headers({
                          Origin: location.origin,
                      }),
                      mode: 'cors',
                  })
                      .then(res => res.blob())
                      .then(blob => {
                          // blobUrl是同源的
                          const blobUrl = window.URL.createObjectURL(blob);
                          download(blobUrl, filename);
                          window.URL.revokeObjectURL(blobUrl);
                      });
              }
     ```



