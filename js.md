# js基础总结

### == 比较的规则
```
1. == 比较会先将两边的数据隐式转换为相同类型， 然后在进行比较
2. null == undefined 是相等的， 而且null 还有 undefined 和其他值比较时不会被隐式转换类型，其他值正常进行隐式转换后也不能转换为null 和 undefined， 和他们类型不同, 所以null 和 undefined和其他值都不相等
3. 在进行原始类型的 == 比较隐式转换过程中， 地位的高低分别为 number（不需要进行隐式转换） > string(和数字进行比较的时候， 要隐式转换为数字后，在和数字进行比较) > boolean （和数字或者字符串进行比较的时候， 要先转换为数字然后在和它们进行比较）
4. 复杂类型 和 原始类型进行 == 比较时， 地位是最低的，首先隐式转换复杂类型为原始类型（就是执行ToPrimitive）， 然后在和原始类型数据进行比较
5. 原始类型进行 == 比较时， 需要两个值类型相同时才开始比较， 除了不能将类型为相同的时候
```

### js 类型转换的步骤， 隐式和显示是相同的步骤， 显式和隐式是从感官上区命名的， 转换原理是相同

```
1. 首先 执行ToPrimitive ， 将值转换为原始值, 执行下面两种转换的前是先执行ToPrimitive
2. 如果要转换为 number就是ToNumber, ToNumber的时候， 首先执行ToPrimitive， 然后将结果转换为number
3. 如果要转换为 string就是ToString, ToString的时候， 首先执行ToPrimitive， 然后将结果转换为string
4. ToPrimitive转换的规则， 就是如果是原始类型， 直接就返回原始类型的值，只有Date实例转化时参数是string， 其他类型转换是参数都是number， 类型是number就是先执行valueOf(), 不行在执行toString(), 而类型是string， 就是先执行toString()，不行在执行valueOf()
```

### js 显式转换

```
!a, +a, Boolean(), String(), Number() 这些都属于js显式转换
```

### js表达式和语句
```
例如这是表达式
3 * 4

每个表达式都有一个结果值，3 * 4这个表达式的结果值，就是3 * 4的结果

表达式和运算符组合在一起就是语句了, 语句有的没有结果值，有的有结果值

let c = a * 4, 这就是语句，这是一个赋值语句

比较特殊的情况
{} ， 既可以表示空对象， 也可以表示一个代码块

{} + [], 这里{}就表示代码块，所有实际代码 就是 +[], 所以结果是0
```

### js运算符优先级

```
() > && > || > ?: > = > ,

let f, t = 12, n  , 这个代码只有t被赋值为12， f和n都是相当于初始化变量， 值都是undefined
```

### js 事件循环的异步操作的理解

js引擎线程就是执行js的， 执行完异步操作的初始化之后， 就会浏览器或者其他js宿主环境就会监听， 异步操作是否完成， 如果完成了， 就会将回调函数放在异步队列里面， 等候在js引擎线程执行

js事件循环的循环的执行顺序是：

1. 同步代码执行
2. 本轮循环执行： 本轮循环包括： node的process.nextTick, 的回调（这是本轮循环中优先级最高的），和微任务队列里边的任务（promise.then的回调就是微任务），微任务的优先级低于process.nextTick的任务， 高于宏任务队列里边的任务，本轮循环执行就是在同步代码执行完之后就立即执行
3. 次轮循环执行： 次轮循环执行就是执行， 宏任务队列里边的任务， 次轮循环执行就是在本轮循环执行完之后执行

宏任务有： setTimeout、setInterval， dom事件

微任务: promise.then 、process.nextTick

不是异步任务的都是同步任务， 同步任务不一定都在层级中，不一定都比异步任务先执行完毕

同步任务的优先级高于异步任务的执行

代码执行就分同步任务和异步任务的执行顺序，不管代码的层级
### async 函数
1. async 函数的调用就是创造promise实例的过程， 所以async 函数的调用就是和new Promise的实例化是一样的， 都是同步的，

2. async  await 后面的promise返回状态后， 获取then的值这个回调就被扔到了微任务队列里边， 如果当前有同步任务就执行同步任务， 执行完同步任务后， 在接着执行异步任务

3. 由于await 后面微任务没有被执行的时候，await下面的代码是不执行的， 所以 await 后面微任务没有被执行的时候，如果有优先级更高的任务， 就先执行优先级更高的任务然后在执行await 后面的微任务

### js 引擎主线程， 任务队列， 事件队列（也就是异步队列）中任务的执行顺序
1. 首先是主线程上的任务执行完毕， 然后任务队列中有任务，先执行任务队列中任务， 等任务队列中的任务执行完毕了， 才去执行事件队列中的任务
2. 主线程中同时只能执行一个任务
3. 不管事件和任务如何嵌套触发， 事件队列和任务队列一直就只有一个（队列先进先出），js执行的主线程也只有一个， 因为事件和任务都是触发了之后才被放到任务队列或者事件队列中去的， 所以嵌套也是没有关系的， 嵌套的事件和任务在队列中永远在上一个触发的事件和任务之后

### js 已经引擎会先将js代码编译成，执行速度最快的代码， 然后在去执行， 所以我们写的代码和js引擎最后执行的代码可能是不一样的（这也叫js的预编译）， 是js引擎底层提供的优化

### + 隐式转换的规则
```
先从 + 左边的值进行隐式转换， 执行ToPrimitive， 然后在 + 右边的值隐式转换， 执行ToPrimitive， 然后将左右两边的转换结果， 使用 + 组合到一起
```

### 函数默认参数使用
函数后一个参数的默认值可以引用前一个参数的值， 可以是前一个参数的默认值， 或者是调用时传入的值

### try

try 可以和 catch 一起使用， 也可以try .. finally 这样使用

### switch 使用

switch当匹配到的case执行后没有break掉， 会继续执行下面没有匹配到的case的代码， 知道出现break之后才结束

# Promise 总结

1. 所有创建resolve状态Promise的过程， 如果遇到了一个返回，状态返回值就是promise实例的情况， 那就直接展开这个promise实例， 作为需要创建的promise实例的结果

2. 使用.catch去捕获异常， 不要使用.then的第二个参数， 因为.then的第二个参数只能捕获.then对应父级实例创建过程中的异常， 不能在捕获.then第一个参数回调执行过程中的异常了， 但是.catch可以

# ts总结
```
1. 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。
```

# 元素位置和宽高的获取总结

scrollHeight : 元素不包括border，只有padding 和 内容的高度（如果有y轴滚动条， 那内容的高度就是y轴滚动条包含的内容高度）

scrollWidth: 和scrollHeight同理

scrollTop: 没有y轴滚动条时是0，有y轴滚动条时，等于滚动条向上滚动的高度

scrollLeft: 和scrollTop同理

clientHeight: 元素不包括border， 只有padding 和内容的高度， 如果有x轴滚动条，整体高度要减去x轴滚动条的宽度

clientWidth: 和clientHeight同理

clientTop: 元素上边框的宽度， 没有上边框就是0

clientLeft: 元素左边框的宽度， 没有左边框就是0

offsetHeight: 元素包括border在内的高度

offsetWidth: 元素包括border在内的宽度

offsetTop: 元素如果上边有相邻的兄弟元素， 那offsetTop就是元素的上边和上边兄弟元素下边的距离，如果没有，那就是元素上边距离元素父元素上边的距离

offsetLeft: 元素如果左边有相邻的兄弟元素， 那offsetLeft就是元素左边和左边兄弟元素右边的距离，如果没有，那就是元素左边距离元素父元素左边的距离

window.getComputedStyle(元素， null): 获取元素在页面上展示出的真实css属性值， 和css文件设置还是行内样式设置样式无关

element.getBoundingClientRect(): 获取元素相对于视口的位置
```
返回值
{
    top: 元素上边距离视口上边的距离
    bottom: 元素下边距离视口上边的距离
    left: 元素左边距离视口左边的距离
    right: 元素右边距离视口左边的距离
    width: 元素的offsetWidth
    height: 元素的offsetHeight
    x: 元素左边距离视口左边的距离
    y: 元素上边距离视口上边的距离
}
```

# 正则表达式

正则表达式的作用: 匹配完整的字符串， 或者匹配字符串中的一部分， 当时设置了完整的开头和结尾的就是匹配符合规则的完整字符串， 如果只设置了开头或者结尾，那就是匹配对开头和结尾有要求的不完整字符串，如果没有设置开头和结尾，那就是匹配字符串中任意部分

特殊注意点： |（或） 操作符，如果不在分组内（例如:/^1|2$/ ）, 就是作用于整个整个正则表达式的， 意义就是匹配以1开头的或者以2结尾的字符串， 如果 | 在分组中 (例如： /^(1|2)$/), 这是或只作用域正则表达式内部，意思就是匹配只有一个字符的字符串1或者字符串2

（）：分组： 内部可以匹配一个字符，也可以匹配多个字符


# 数组

1. 数字的sort 方法  的回调两个参数分别带代表数组的前后两个值，只有当函数返回值小于0时，两个顺序才发生变化，否则在大于0和等于0时两个值的顺序是不变的


# for 循环 （）中是一个作用域 ，{} 是（）的子作用域， 所以是两个作用域

### 问题

1. 简单介绍一下原型链

说到原型链不得不说的就是函数了，因为原型链的起源就在函数, 首先每个函数都有一个prototype属性, 当我们将这个函数当做构造函数通过new 调用创建一个实例时, 创建的这个实例的__proto__属性就指向构造函数的prototype属性, 而构造函数的prototype属性本身也是一个对象实例，所以它也有__proto__属性，它的__proto__属性指向Object.prototype，Object.prototype也是一个对象实例，所以它也有__proto__属性， 不过它的__proto__属性，指向的是null，这就是原型链的基本链，
还有一些特殊的情况，比如所有的函数都是Function 的实例， 所有Function也是自己的实例， 所以Function.__proto__ === Function.prototype, Object也是Function的实例，原型链不止是__proto__和prototype这样的指向关系，最主要的是对象实例可以通过原型链获取到自己本身没有，但是原型链上有的属性，这才是原型链的本质作用, 我们常说的原型继承就是通过这个原理实现的

2. 说一下对作用域链的理解

说作用域链之前我们得先了解一下我们都有几种作用域， 首先是全局作用域，函数作用域和块级作用域,
此外还有词法作用域就是静态作用域，就是不通过eval等动态执行代码的时候这种作用域，使用eval等执行代码的时候的作用域是动态作用域， 动态和静态作用域都包括全局作用域，函数作用域和块级作用域

作用域的定义我理解就是变量的作用范围， 上下文就是代码执行时候的环境，这个环境就是作用域的作用范围

我们都知道当我们引用一个变量的时候，当前作用域没有， 代码会一直向外层查找变量，一直可以查到全局变量， 如果在全局作用域也没有查找到， 那就是抛错， 这个查找的链路在我理解就是作用域链

查找变量的作用域范围， 静态作用域是在代码解析阶段就确定了， 而动态作用域是在代码执行阶段才确定

3. 介绍一下块级作用域

块级作用域是我们在es6以后提出来的概念，主要是通过let 和const 定义变量所在的块中，就形成一个块级作用域， 比如在一个if {} 中通过let 定义一个变量这个if {}就形成了一个块级作用域， 并且
作用域中的变量不能被块以外的其他区域引用x

4. let const var 的区别

1. let 和const 定义的变量没有变量提升

2. let 和const 创建变量 会形成一个块级作用域

3. 在let 或者const 的变量之前引用这个变量，或者使用typeof或者这个变量的类型， 都会报错，这都是因为引用变量的范围都在暂时性死区中， 所以才会报错
4. 由于let 和const 没有变量提升， 所以在变量定义之前引用变量都是在暂时性死区中

5. let 和const 定义变量之前就是暂时性死区， 所以在let和const定义变量之前引用变量就会报错，
产生暂时性死区就是代码解析阶段发现引用变量是被let和const定义的，那就认为这个变量的的查找只能在当前let和const定义的块级作用域内，如果变量是在声明前引用那就是在暂时性死区， 就会报错,

暂时性死区是作用域链的一种特殊情况， 就是let 定义之前引用这个变量，这个变量在解析阶段，它的查找范围就已经被确定在let 和const定义变量的这个块级作用域中了， 所以暂时性死


5. 介绍一下闭包

我理解的闭包就是 在当前作用域下声明的函数，在当前作用域以外的作用域被调用，就形成了闭包， 比如注册事件的回调，这就形成了一个闭包

闭包的作用就是保存变量， 让函数内的变量可以被函数外部使用和操作

但是很使用闭包的时候也需要注意，可能会出现内存泄露的问题，影响页面的性能


6. 介绍一下页面的垃圾回收机制

垃圾回收机制是浏览器的一种优化策略（垃圾回收机制准确说是V8引擎这个js引擎线程的优化策略）， 当触发垃圾回收机制的时候， 会将不需要在使用的内存（就是分配给V8引擎的内存）释放掉，然后将内存分配给需要的变量，垃圾回收的方式一般 分为三中 引用计数、标记清除、和标记整理，我们现在的浏览器都是标记清除和标记整理两种形式一起使用，因为标记清除相对标记整理进行垃圾回收的速度更快，因为标记清除不需要移动对象， 而标记整理需要移动对象， 所以速度更慢, 但是在标记清除也有自己的问题，就是垃圾回收后的内存不连续，导致虽然垃圾回收后，所剩内存的总和是够的， 但是不能总的内存一次分配给一个对象，所有这种情况下，就需要使用标记管理，标记管理可以使回收后的内存连起来，但是由于垃圾回收也是占用浏览器主线程的，所以执行垃圾回收的时候js代码不会执行， 页面渲染也不会执行，影响页面展示，所以垃圾回收的时间也不适宜太长， 所以主要是使用标记清除的方式

7. 什么时候触发垃圾回收机制呢

执行垃圾回收的时间是周期性的， 隔一段时间机会进行一次垃圾回收，不会是函数完毕就会触发垃圾回收, 但是也不是固定的， 可能在内存消耗过大时， 提前开启垃圾回收

8. 函数只有在每次调用的时候才会创建这个函数执行上下文和作用域，还有为函数中的变量分配内存，但是函数执行完毕后， 执行上下文和作用域都会销毁，给变量分配的内存也会在下一次垃圾回收的时候被收回

还有给变量设置为null之后， 之前分配的内存都会被回收

#### 不会被回收的内存

1. window 本事永远不会被回收，

2. window 上的全局属性永远不会被回收，

3. 全局变量引用的对象永远不会被回收

4. 闭包函数返回的函数所引用的闭包函数中的变量， 不会被回收， 除非接收这个返回函数的变量置为null， 才会被回收

5. 还有就是最正常的情况，当前正在使用这个变量时， 内存不会被回收





9. 什么是浏览器的主进程

浏览器主进程就是将js引擎线程和GUi渲染线程等真实的线程包装成一个虚拟的线程，然后根据情况，采用不同的真实线程处理任务， 所以说浏览器主线程可以说是一个概念，并不是一个真正的线程

10. 对浏览器的理解





