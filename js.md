# js基础总结

### == 比较的规则
```
1. == 比较会先将两边的数据隐式转换为相同类型， 然后在进行比较
2. null == undefined 是相等的， 而且null 还有 undefined 和其他值比较时不会被隐式转换类型，其他值正常进行隐式转换后也不能转换为null 和 undefined， 和他们类型不同, 所以null 和 undefined和其他值都不相等
3. 在进行原始类型的 == 比较隐式转换过程中， 地位的高低分别为 number（不需要进行隐式转换） > string(和数字进行比较的时候， 要隐式转换为数字后，在和数字进行比较) > boolean （和数字或者字符串进行比较的时候， 要先转换为数字然后在和它们进行比较）
4. 复杂类型 和 原始类型进行 == 比较时， 地位是最低的，首先隐式转换复杂类型为原始类型（就是执行ToPrimitive）， 然后在和原始类型数据进行比较
5. 原始类型进行 == 比较时， 需要两个值类型相同时才开始比较， 除了不能将类型为相同的时候
```

### js 类型转换的步骤， 隐式和显示是相同的步骤， 显式和隐式是从感官上区命名的， 转换原理是相同

```
1. 首先 执行ToPrimitive ， 将值转换为原始值, 执行下面两种转换的前是先执行ToPrimitive
2. 如果要转换为 number就是ToNumber, ToNumber的时候， 首先执行ToPrimitive， 然后将结果转换为number
3. 如果要转换为 string就是ToString, ToString的时候， 首先执行ToPrimitive， 然后将结果转换为string
4. ToPrimitive转换的规则， 就是如果是原始类型， 直接就返回原始类型的值，只有Date实例转化时参数是string， 其他类型转换是参数都是number， 类型是number就是先执行valueOf(), 不行在执行toString(), 而类型是string， 就是先执行toString()，不行在执行valueOf()
```

### js 显式转换

```
!a, +a, Boolean(), String(), Number() 这些都属于js显式转换
```

### js表达式和语句
```
例如这是表达式
3 * 4

每个表达式都有一个结果值，3 * 4这个表达式的结果值，就是3 * 4的结果

表达式和运算符组合在一起就是语句了, 语句有的没有结果值，有的有结果值

let c = a * 4, 这就是语句，这是一个赋值语句

比较特殊的情况
{} ， 既可以表示空对象， 也可以表示一个代码块

{} + [], 这里{}就表示代码块，所有实际代码 就是 +[], 所以结果是0
```

### js运算符优先级

```
() > && > || > ?: > = > ,

let f, t = 12, n  , 这个代码只有t被赋值为12， f和n都是相当于初始化变量， 值都是undefined
```

### js 事件循环的异步操作的理解

js引擎线程就是执行js的， 执行完异步操作的初始化之后， 就会浏览器或者其他js宿主环境就会监听， 异步操作是否完成， 如果完成了， 就会将回调函数放在异步队列里面， 等候在js引擎线程执行

js事件循环的循环的执行顺序是：

1. 同步代码执行
2. 本轮循环执行： 本轮循环包括： node的process.nextTick, 的回调（这是本轮循环中优先级最高的），和微任务队列里边的任务（promise.then的回调就是微任务），微任务的优先级低于process.nextTick的任务， 高于宏任务队列里边的任务，本轮循环执行就是在同步代码执行完之后就立即执行
3. 次轮循环执行： 次轮循环执行就是执行， 宏任务队列里边的任务， 次轮循环执行就是在本轮循环执行完之后执行

### async 函数
1. async 函数的调用就是创造promise实例的过程， 所以async 函数的调用就是和new Promise的实例化是一样的， 都是同步的，
但是特殊的是当遇到第一个 await的时候，会将await之后的代码都执行完，然后await下面的代码都先不执行，如果第一个await后面的代码同步的返回了promise的状态，会等到和它平级的微任务都执行完毕， 然后在开始执行await后面的那些代码，如果没有返回promise的状态
2. 如果阻止promise的确定状态的任务是微任务， 那就执行完这个微任务然后在执行第一个await之后的代码
3. 如果阻止promise的确定状态的任务是宏任务，那就按照一级的宏任务的顺序执行这个宏任务， 然后在执行第一个await之后的代码

### js 引擎主线程， 任务队列， 事件队列（也就是异步队列）中任务的执行顺序
1. 首先是主线程上的任务执行完毕， 然后任务队列中有任务，先执行任务队列中任务， 等任务队列中的任务执行完毕了， 才去执行事件队列中的任务
2. 主线程中同时只能执行一个任务
3. 不管事件和任务如何嵌套触发， 事件队列和任务队列一直就只有一个（队列先进先出），js执行的主线程也只有一个， 因为事件和任务都是触发了之后才被放到任务队列或者事件队列中去的， 所以嵌套也是没有关系的， 嵌套的事件和任务在队列中永远在上一个触发的事件和任务之后

### js 已经引擎会先将js代码编译成，执行速度最快的代码， 然后在去执行， 所以我们写的代码和js引擎最后执行的代码可能是不一样的（这也叫js的预编译）， 是js引擎底层提供的优化

### + 隐式转换的规则
```
先从 + 左边的值进行隐式转换， 执行ToPrimitive， 然后在 + 右边的值隐式转换， 执行ToPrimitive， 然后将左右两边的转换结果， 使用 + 组合到一起
```

### 函数默认参数使用
函数后一个参数的默认值可以引用前一个参数的值， 可以是前一个参数的默认值， 或者是调用时传入的值

### try

try 可以和 catch 一起使用， 也可以try .. finally 这样使用

### switch 使用

switch当匹配到的case执行后没有break掉， 会继续执行下面没有匹配到的case的代码， 知道出现break之后才结束

# Promise 总结

1. 所有创建resolve状态Promise的过程， 如果遇到了一个返回，状态返回值就是promise实例的情况， 那就直接展开这个promise实例， 作为需要创建的promise实例的结果

2. 使用.catch去捕获异常， 不要使用.then的第二个参数， 因为.then的第二个参数只能捕获.then对应父级实例创建过程中的异常， 不能在捕获.then第一个参数回调执行过程中的异常了， 但是.catch可以

# ts总结
```
1. 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。
```

# 元素位置和宽高的获取总结

scrollHeight : 元素不包括border，只有padding 和 内容的高度（如果有y轴滚动条， 那内容的高度就是y轴滚动条包含的内容高度）

scrollWidth: 和scrollHeight同理

scrollTop: 没有y轴滚动条时是0，有y轴滚动条时，等于滚动条向上滚动的高度

scrollLeft: 和scrollTop同理

clientHeight: 元素不包括border， 只有padding 和内容的高度， 如果有x轴滚动条，整体高度要减去x轴滚动条的宽度

clientWidth: 和clientHeight同理

clientTop: 元素上边框的宽度， 没有上边框就是0

clientLeft: 元素左边框的宽度， 没有左边框就是0

offsetHeight: 元素包括border在内的高度

offsetWidth: 元素包括border在内的宽度

offsetTop: 元素如果上边有相邻的兄弟元素， 那offsetTop就是元素的上边和上边兄弟元素下边的距离，如果没有，那就是元素上边距离元素父元素上边的距离

offsetLeft: 元素如果左边有相邻的兄弟元素， 那offsetLeft就是元素左边和左边兄弟元素右边的距离，如果没有，那就是元素左边距离元素父元素左边的距离

window.getComputedStyle(元素， null): 获取元素在页面上展示出的真实css属性值， 和css文件设置还是行内样式设置样式无关

element.getBoundingClientRect(): 获取元素相对于视口的位置
```
返回值
{
    top: 元素上边距离视口上边的距离
    bottom: 元素下边距离视口上边的距离
    left: 元素左边距离视口左边的距离
    right: 元素右边距离视口左边的距离
    width: 元素的offsetWidth
    height: 元素的offsetHeight
    x: 元素左边距离视口左边的距离
    y: 元素上边距离视口上边的距离
}
```

# 正则表达式

正则表达式的作用: 匹配完整的字符串， 或者匹配字符串中的一部分， 当时设置了完整的开头和结尾的就是匹配符合规则的完整字符串， 如果只设置了开头或者结尾，那就是匹配对开头和结尾有要求的不完整字符串，如果没有设置开头和结尾，那就是匹配字符串中任意部分

特殊注意点： |（或） 操作符，如果不在分组内（例如:/^1|2$/ ）, 就是作用于整个整个正则表达式的， 意义就是匹配以1开头的或者以2结尾的字符串， 如果 | 在分组中 (例如： /^(1|2)$/), 这是或只作用域正则表达式内部，意思就是匹配只有一个字符的字符串1或者字符串2

（）：分组： 内部可以匹配一个字符，也可以匹配多个字符


